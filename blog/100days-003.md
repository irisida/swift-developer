# Day 3 - Operators and conditions

### OPerator basics and types considerations

Swift has all the usual programmatic operators open to the engineer in the form of `+, -, *, /, %`. We also see some common types to programming languages such as `Int` for integers or _whole numbers_. For numbers with decimal places we have both `Float` and `Double` and the preference is for engineers to use Double on the basis of it being more reliable.

One interesting question is why numerical types can't be mixed. In the real work it's not unheard of to add a whole number and a number with a decimal part. This is not allowed in Swift largely because of the way the language manages storage and for the way precision is representable. Integers have no ability to store fractional values, but are considered better at storing more precise numbers. In order to make mixed types operations we are required to cast to the relevant number types that would allow such a conversion.

```swift
let dec = 55.9005
let whole = 100

// this example converts the int value to a double and therefore allows for a
// non-lossy addition.
var added = dec + Double(whole)
```

### Compound operators

We can use language efficiencies to shorten the declaration of operations. This works for the `+, -, *, /` operators.

```swift
// lets start with a base number
var num = 100

// declare an add operation.
num = num + 100

// this can be rewritten with a compound operator
num += 100 // this makes num = 200 as it's the same as the code above

num -= 50 // is the same as num = 200 - 50, or 150
```

### Combining conditions

Combining conditions is useful but we're starting to reduce immediate readability of the code. We can be expressive with combined conditions but we should also be mindful that readability is king and code os read far more often than it is written.

```swift
var a = 5
var b = 20

if a <= 10 && b > 20 {
  doThisOperation()
} else {
  doThatOperationInstead()
}
```

When we see a statement like this we're evaluating truthyness and falseyness of each statement and languages implementing these type of capabilities have compiler efficiencies built in. In the case above we see a logical AND operator used to evaluate two conditions - one os a combined operator and one a single operator. This statement above will call `doThatOperationInstead()` because `b` is not greater than 20, it is equal to 20. Where we had a similar operation with a logical OR operation the minute one side evaluated true it would be true and avoid the wasted CPU time of evaluating the other side. See below

```swift
var a = 5
var b = 20

if a <= 10 || b > 20 {
  doThisOperation()
} else {
  doThatOperationInstead()
}
```

This time we call the `doOperation()` because `a` is less than or equal to 10 when a is equal to 5. What we're hoping ot avoid is situations in code like this one below. If you see this in a PR, have a word with that person. Readability is king!

```swift
var a = 5
var b = 20

if (a <= 10 && b > 20) &&  a != b || a > b {
  doThisOperation()
} else {
  doThatOperationInstead()
}
```

### The ternary operator

The ternary operator in part solves some readability issues, but is another case where heavy nesting should be avoided. With great power comes great responsibility and so on. So let's have a look at a ternary operator.

```swift
let number = 100
 print(number > 10 ? "YES" : "no") // statement ?  true case : false case
```

That brings the examples for day 3 to a close.

Be safe, be well
